scalar JSONObject
directive @oneOf on INPUT_OBJECT | FIELD_DEFINITION

input AuthOr {
  includes: JSONObject
  match: JSONObject
}

directive @auth(
  match: JSONObject,
  skip: Boolean
  includes: JSONObject
  or: [AuthOr!]
) on FIELD_DEFINITION

scalar Date
scalar DateTime

type Query {
  entity(name: String!): Entity
  entities: [Entity!]!
}

type Mutation {
  createEntity(name: String!): Entity! @auth(includes: { permissions: "modify-entity" })
  removeEntity(name: String!): Boolean! @auth(includes: { permissions: "modify-entity" })

  addFieldsToEntity(entityName: String!, fields: [FieldInput!]!): Entity! @auth(includes: { permissions: "modify-entity" })
  removeFieldsFromEntity(entityName: String!, fields: [String!]!): Entity! @auth(includes: { permissions: "modify-entity" })
}

input FieldInput @oneOf {
  StringField: StringFieldInput
  NumberField: NumberFieldInput
  BooleanField: BooleanFieldInput
  ArrayField: ArrayFieldInput
  EntityRelationField: EntityRelationFieldInput
}

input FieldInputWithoutArray @oneOf {
  StringField: StringFieldInput
  NumberField: NumberFieldInput
  BooleanField: BooleanFieldInput
  EntityRelationField: EntityRelationFieldInput
}

input StringFieldInput {
  name: String!
  isRequired: Boolean
  maxLength: Int
  minLength: Int
  defaultValue: String
}

input NumberFieldInput {
  name: String!
  isRequired: Boolean
  max: Float
  min: Float
  defaultValue: Float
}

input BooleanFieldInput {
  name: String!
  isRequired: Boolean
  defaultValue: Boolean
}

input ArrayFieldInput {
  name: String!
  availableFields: [FieldInputWithoutArray!]!
  isRequired: Boolean
  maxItems: Int
  minItems: Int
}

input EntityRelationFieldInput {
  name: String!
  #entityName: EntityEnum! // lets make this a string for now, would be nice to tie together with the dynamic schema
  entityName: String!
  isRequired: Boolean!
}

interface Field {
  name: String!
  isRequired: Boolean!
}

type StringField implements Field {
  name: String!
  isRequired: Boolean!
  maxLength: Int
  minLength: Int
  defaultValue: String
}

type IDField implements Field {
  name: String!
  isRequired: Boolean!
}

type NumberField implements Field {
  name: String!
  isRequired: Boolean!
  max: Float
  min: Float
  defaultValue: Float
}

type BooleanField implements Field {
  name: String!
  isRequired: Boolean!
  defaultValue: Boolean
}

# let's make these pluggable
# type DateField implements Field {
#
#   name: String!
#   isRequired: Boolean!
#   min: Date
#   max: Date
# }

# type DateTimeField implements Field {
#
#   name: String!
#   isRequired: Boolean!
#   min: DateTime
#   max: DateTime
# }

# type ImageField implements Field {
#
#   isRequired: Boolean!
#   name: String!
# }

# type VideoField implements Field {
#
#   isRequired: Boolean!
#   name: String!
# }

# type FileField implements Field {
#
#   isRequired: Boolean!
#   name: String!
# }

type ArrayField implements Field {
  name: String!
  availableFields: [Field!]!
  isRequired: Boolean!
  maxItems: Int
  minItems: Int
}

type EntityRelationField implements Field {
  name: String!
  entityName: String!
  entity: Entity!
  isRequired: Boolean!
}

type Entity {
  name: String!
  fields: [Field!]!
}

input EntityInput {
  name: String!
}
