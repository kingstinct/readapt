scalar JSONObject

input AuthOr {
  includes: JSONObject
  match: JSONObject
}

directive @auth(
  match: JSONObject,
  skip: Boolean
  includes: JSONObject
  or: [AuthOr!]
) on FIELD_DEFINITION

type Mutation {
  emailLoginRequest(email: String!): EmailLoginRequestResponse! @auth(skip: true)
  emailLoginConfirm(email: String!, code: String!): EmailLoginConfirmResponse! @auth(skip: true)
  smsLoginRequest(phoneNum: String!): SmsLoginRequestResponse! @auth(skip: true)
  smsLoginConfirm(phoneNum: String!, code: String!): SmsLoginConfirmResponse! @auth(skip: true)
}

type LoginRequestSuccessResponse {
    success: Boolean! @auth(skip: true)
}

type EmailNotValidError implements Error {
    message: String! @auth(skip: true)
}

type PhoneNumNotValidError implements Error {
    message: String! @auth(skip: true)
}

type CodeNotValidError implements Error {
    message: String! @auth(skip: true)
}

type LoginFailedError implements Error {
    message: String! @auth(skip: true)
}

union EmailLoginRequestResponse = LoginRequestSuccessResponse | EmailNotValidError
union SmsLoginRequestResponse = LoginRequestSuccessResponse | PhoneNumNotValidError

type LoginConfirmSuccessfulResponse {
    bearerToken: String! @auth(skip: true)
    refreshToken: String! @auth(skip: true)
}

union EmailLoginConfirmResponse = LoginConfirmSuccessfulResponse
  | EmailNotValidError
  | CodeNotValidError
  | LoginFailedError

union SmsLoginConfirmResponse = LoginConfirmSuccessfulResponse
  | PhoneNumNotValidError
  | CodeNotValidError
  | LoginFailedError

interface Error {
  message: String! @auth(skip: true)
}
